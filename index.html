    function updateTotals(data) {
      const total = data.length;
      const totalWeekdays = data.filter(item => !isWeekend(item.date)).length;
      const totalWeekends = data.filter(item => isWeekend(item.date)).length;
      
      document.getElementById('techStats').innerHTML += `
        <div class="tech-card">
          <h3><i class="fas fa-chart-bar"></i> Totais Consolidados</h3>
          <p>Total Registros: ${total}</p>
          <p>Dias Úteis: ${totalWeekdays} (${Math.round((totalWeekdays/total)*100)}%)</p>
          <p>Finais de Semana: ${totalWeekends} (${Math.round((totalWeekends/total)*100)}%)</p>
        </div>
      `;
    }

    function updateDashboard(data) {
      // Agrupar dados para gráficos
      const volumesAnalista = {};
      const volumesCluster = {};
      const volumesHorario = {};
      const volumesDia = {};
      const volumesPorMes = {};
      const volumesMes = {};
      const volumesDiaSemana = { 'Dias Úteis': 0, 'Finais de Semana': 0 };
      const techStats = { HFC: 0, GPON: 0, OUTROS: 0 };
      const techByCluster = {};

      data.forEach(item => {
        // Analista (apenas os mapeados)
        if (loginToName[item.login]) {
          volumesAnalista[item.login] = (volumesAnalista[item.login] || 0) + 1;
        }
        
        // Cluster
        volumesCluster[item.cluster] = (volumesCluster[item.cluster] || 0) + 1;
        
        // Horário
        volumesHorario[item.time] = (volumesHorario[item.time] || 0) + 1;
        
        // Data
        volumesDia[item.date] = (volumesDia[item.date] || 0) + 1;
        
        // Mês (para destacar dias com maior volume)
        const mes = item.date.substring(0, 7);
        if (!volumesPorMes[mes]) {
          volumesPorMes[mes] = { date: null, volume: 0 };
        }
        if (volumesDia[item.date] > volumesPorMes[mes].volume) {
          volumesPorMes[mes] = { date: item.date, volume: volumesDia[item.date] };
        }
        
        // Volume por mês
        volumesMes[mes] = (volumesMes[mes] || 0) + 1;
        
        // Dias úteis vs finais de semana
        if (isWeekend(item.date)) {
          volumesDiaSemana['Finais de Semana'] += 1;
        } else {
          volumesDiaSemana['Dias Úteis'] += 1;
        }
        
        // Estatísticas de tecnologia
        const tech = item.tecnologia.includes('HFC') ? 'HFC' : 
                    item.tecnologia.includes('GPON') ? 'GPON' : 'OUTROS';
        techStats[tech] = (techStats[tech] || 0) + 1;
        
        // Tecnologia por cluster
        if (!techByCluster[item.cluster]) {
          techByCluster[item.cluster] = { HFC: 0, GPON: 0, OUTROS: 0 };
        }
        techByCluster[item.cluster][tech] += 1;
      });

      // Atualizar estatísticas de tecnologia
      updateTechStats(techStats, techByCluster);
      
      // Atualizar totais consolidados
      updateTotals(data);

      // Adicionar filtros
      addFilters(
        Object.keys(volumesAnalista).map(login => loginToName[login]),
        Object.keys(volumesCluster)
      );

      // Gráfico de Analistas (ordenado por volume)
      const analistasOrdenados = Object.entries(volumesAnalista)
        .sort((a, b) => b[1] - a[1])
        .map(([login]) => ({
          nome: loginToName[login],
          volume: volumesAnalista[login]
        }));
      
      drawChart('chartAnalistas', {
        type: 'bar',
        data: {
          labels: analistasOrdenados.map(a => a.nome),
          datasets: [{
            label: 'Volume por Analista',
            data: analistasOrdenados.map(a => a.volume),
            backgroundColor: '#4361ee',
            borderColor: '#3a0ca3',
            borderWidth: 1,
            barThickness: 'flex',
            maxBarThickness: 50
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          scales: {
            y: {
              beginAtZero: true,
              ticks: {
                callback: function(value) {
                  return value.toLocaleString();
                }
              }
            },
            x: {
              ticks: {
                autoSkip: false,
                maxRotation: 45,
                minRotation: 45
              }
            }
          }
        }
      });

      // Gráfico de Clusters (ordenado por volume)
      const clustersOrdenados = Object.entries(volumesCluster)
        .sort((a, b) => b[1] - a[1]);
      
      drawChart('chartClusters', {
        type: 'bar',
        data: {
          labels: clustersOrdenados.map(c => c[0]),
          datasets: [{
            label: 'Volume por Cluster',
            data: clustersOrdenados.map(c => c[1]),
            backgroundColor: '#4361ee',
            borderColor: '#3a0ca3',
            borderWidth: 1,
            barThickness: 'flex',
            maxBarThickness: 50
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          scales: {
            y: {
              beginAtZero: true,
              ticks: {
                callback: function(value) {
                  return value.toLocaleString();
                }
              }
            },
            x: {
              ticks: {
                autoSkip: false,
                maxRotation: 45,
                minRotation: 45
              }
            }
          }
        }
      });

      // Gráfico de Horários (ordenado por volume)
      const horariosOrdenados = Object.entries(volumesHorario)
        .sort((a, b) => b[1] - a[1]);
      
      drawChart('chartHorarios', {
        type: 'bar',
        data: {
          labels: horariosOrdenados.map(h => h[0]),
          datasets: [{
            label: 'Volume por Horário',
            data: horariosOrdenados.map(h => h[1]),
            backgroundColor: '#4361ee',
            borderColor: '#3a0ca3',
            borderWidth: 1,
            barThickness: 'flex',
            maxBarThickness: 50
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          scales: {
            y: {
              beginAtZero: true,
              ticks: {
                callback: function(value) {
                  return value.toLocaleString();
                }
              }
            },
            x: {
              ticks: {
                autoSkip: false,
                maxRotation: 45,
                minRotation: 45
              }
            }
          }
        }
      });

      // Gráfico de Volume por Mês
      const mesesOrdenados = Object.keys(volumesMes).sort();
      drawChart('chartMeses', {
        type: 'bar',
        data: {
          labels: mesesOrdenados.map(m => {
            const [year, month] = m.split('-');
            return `${getMonthName(m + '-01')} ${year}`;
          }),
          datasets: [{
            label: 'Volume por Mês',
            data: mesesOrdenados.map(m => volumesMes[m]),
            backgroundColor: '#4361ee',
            borderColor: '#3a0ca3',
            borderWidth: 1
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          scales: {
            y: {
              beginAtZero: true,
              ticks: { callback: value => value.toLocaleString() }
            },
            x: {
              ticks: { autoSkip: false }
            }
          }
        }
      });

      // Gráfico Dias Úteis vs Finais de Semana
      drawChart('chartDiasSemana', {
        type: 'pie',
        data: {
          labels: Object.keys(volumesDiaSemana),
          datasets: [{
            data: Object.values(volumesDiaSemana),
            backgroundColor: ['#4361ee', '#4cc9f0'],
            borderColor: ['#3a0ca3', '#3a0ca3'],
            borderWidth: 1
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            tooltip: {
              callbacks: {
                label: function(context) {
                  const total = context.dataset.data.reduce((a, b) => a + b, 0);
                  const value = context.raw;
                  const percentage = Math.round((value / total) * 100);
                  return `${context.label}: ${value} (${percentage}%)`;
                }
              }
            }
          }
        }
      });

      // Gráfico de Dias com apenas os destaques mensais em ordem cronológica
      const meses = Object.keys(volumesPorMes).sort();
      const diasDestaque = meses.map(mes => volumesPorMes[mes].date);
      const volumesDestaque = diasDestaque.map(d => volumesDia[d]);
      
      drawChart('chartDias', {
        type: 'bar',
        data: {
          labels: diasDestaque,
          datasets: [{
            label: 'Volume nos Dias de Maior Movimento',
            data: volumesDestaque,
            backgroundColor: '#4361ee',
            borderColor: '#3a0ca3',
            borderWidth: 1,
            barThickness: 'flex',
            maxBarThickness: 50
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            tooltip: {
              callbacks: {
                afterLabel: function(context) {
                  const date = new Date(context.label);
                  const month = date.toLocaleString('pt-BR', { month: 'long' });
                  return `Destaque de ${month.charAt(0).toUpperCase() + month.slice(1)}`;
                }
              }
            }
          },
          scales: {
            y: {
              beginAtZero: true,
              ticks: {
                callback: function(value) {
                  return value.toLocaleString();
                }
              }
            },
            x: {
              ticks: {
                autoSkip: false,
                maxRotation: 45,
                minRotation: 45
              }
            }
          }
        }
      });

      // Gráfico de Proporção HFC/GPON por Cluster
      const clustersTech = Object.keys(techByCluster);
      const techClusterData = {
        labels: clustersTech,
        datasets: [
          {
            label: 'HFC',
            data: clustersTech.map(c => techByCluster[c].HFC),
            backgroundColor: '#4361ee'
          },
          {
            label: 'GPON',
            data: clustersTech.map(c => techByCluster[c].GPON),
            backgroundColor: '#4cc9f0'
          },
          {
            label: 'Outros',
            data: clustersTech.map(c => techByCluster[c].OUTROS),
            backgroundColor: '#e9ecef'
          }
        ]
      };
      
      drawChart('chartTechCluster', {
        type: 'bar',
        data: techClusterData,
        options: {
          responsive: true,
          maintainAspectRatio: false,
          scales: {
            x: {
              stacked: true,
              ticks: {
                autoSkip: false,
                maxRotation: 45,
                minRotation: 45
              }
            },
            y: {
              stacked: true,
              beginAtZero: true,
              ticks: {
                callback: function(value) {
                  return value.toLocaleString();
                }
              }
            }
          }
        }
      });

      // Tabela (apenas analistas mapeados)
      updateTable(analistasOrdenados.map(a => a.nome), data, techByCluster);
    }

    function updateTechStats(techStats, techByCluster) {
      const total = techStats.HFC + techStats.GPON + techStats.OUTROS;
      const stats
    function updateTechStats(techStats, techByCluster) {
      const total = techStats.HFC + techStats.GPON + techStats.OUTROS;
      const statsContainer = document.getElementById('techStats');
      
      statsContainer.innerHTML = `
        <div class="tech-card">
          <h3><i class="fas fa-network-wired"></i> Distribuição por Tecnologia</h3>
          <p>HFC: ${techStats.HFC} (${((techStats.HFC / total) * 100).toFixed(1)}%)</p>
          <p>GPON: ${techStats.GPON} (${((techStats.GPON / total) * 100).toFixed(1)}%)</p>
          <p>Outros: ${techStats.OUTROS} (${((techStats.OUTROS / total) * 100).toFixed(1)}%)</p>
        </div>
        
        <div class="tech-card">
          <h3><i class="fas fa-chart-pie"></i> Proporção HFC/GPON</h3>
          <p>Total HFC: ${techStats.HFC}</p>
          <p>Total GPON: ${techStats.GPON}</p>
          <p>Razão: ${(techStats.HFC / techStats.GPON).toFixed(2)}:1</p>
        </div>
      `;
      
      // Adiciona cards para cada cluster
      Object.entries(techByCluster).forEach(([cluster, techs]) => {
        const totalCluster = techs.HFC + techs.GPON + techs.OUTROS;
        statsContainer.innerHTML += `
          <div class="tech-card">
            <h3><i class="fas fa-project-diagram"></i> Cluster ${cluster}</h3>
            <p>HFC: ${techs.HFC} (${((techs.HFC / totalCluster) * 100).toFixed(1)}%)</p>
            <p>GPON: ${techs.GPON} (${((techs.GPON / totalCluster) * 100).toFixed(1)}%)</p>
            <p>Razão: ${(techs.HFC / techs.GPON).toFixed(2)}:1</p>
          </div>
        `;
      });
    }

    function addFilters(analistas, clusters) {
      const filtersContainer = document.getElementById('filtersContainer');
      
      filtersContainer.innerHTML = `
        <div class="filter-group">
          <label>Analistas:</label>
          <select id="analistaFilter" multiple>
            ${analistas.map(a => `<option value="${a}" selected>${a}</option>`).join('')}
          </select>
        </div>
        <div class="filter-group">
          <label>Clusters:</label>
          <select id="clusterFilter" multiple>
            ${clusters.map(c => `<option value="${c}" selected>${c}</option>`).join('')}
          </select>
        </div>
        <button id="applyFilters">Aplicar Filtros</button>
      `;
      
      filtersContainer.style.display = 'grid';
      
      document.getElementById('applyFilters').addEventListener('click', () => {
        const selectedAnalistas = [...document.getElementById('analistaFilter').selectedOptions]
          .map(opt => opt.value);
        const selectedClusters = [...document.getElementById('clusterFilter').selectedOptions]
          .map(opt => opt.value);
        
        if (currentData) {
          const filteredData = currentData.filter(item => {
            const nomeAnalista = loginToName[item.login];
            return selectedAnalistas.includes(nomeAnalista) && 
                   selectedClusters.includes(item.cluster);
          });
          
          updateDashboard(filteredData);
        }
      });
    }

    function updateTable(analistasFiltrados, data, techByCluster) {
      const tabela = document.getElementById('tabela');
      
      // Agrupar por analista (apenas os filtrados)
      const resumo = data.reduce((acc, item) => {
        if (!analistasFiltrados.includes(loginToName[item.login])) return acc;
        
        if (!acc[item.login]) {
          acc[item.login] = {
            nome: loginToName[item.login],
            total: 0,
            clusters: {},
            tecnologias: { HFC: 0, GPON: 0, OUTROS: 0 }
          };
        }
        
        acc[item.login].total++;
        acc[item.login].clusters[item.cluster] = (acc[item.login].clusters[item.cluster] || 0) + 1;
        
        const tech = item.tecnologia.includes('HFC') ? 'HFC' : 
                     item.tecnologia.includes('GPON') ? 'GPON' : 'OUTROS';
        acc[item.login].tecnologias[tech] += 1;
        
        return acc;
      }, {});

      // Criar HTML da tabela
      let html = `
        <table class="data-table">
          <thead>
            <tr>
              <th>Analista</th>
              <th>Total</th>
              <th>HFC</th>
              <th>GPON</th>
              <th>Proporção</th>
              <th>Clusters</th>
            </tr>
          </thead>
          <tbody>
      `;

      Object.entries(resumo)
        .sort((a, b) => b[1].total - a[1].total)
        .forEach(([, info]) => {
          const clusters = Object.entries(info.clusters)
            .sort((a, b) => b[1] - a[1])
            .map(([cluster, count]) => `${cluster}: ${count}`)
            .join('<br>');
          
          const proporcao = info.tecnologias.GPON > 0 ? 
                           (info.tecnologias.HFC / info.tecnologias.GPON).toFixed(2) + ':1' : 
                           'N/A';
          
          html += `
            <tr>
              <td>${info.nome}</td>
              <td>${info.total.toLocaleString()}</td>
              <td>${info.tecnologias.HFC}</td>
              <td>${info.tecnologias.GPON}</td>
              <td>${proporcao}</td>
              <td>${clusters}</td>
            </tr>
          `;
        });

      html += `
          </tbody>
        </table>
      `;

      tabela.innerHTML = html;
    }
    function exportChartsAsPNG() {
      showLoading("Preparando gráficos para exportação...");
      
      setTimeout(() => {
        Object.keys(charts).forEach((chartId, index) => {
          const link = document.createElement('a');
          link.download = `grafico_${chartId}.png`;
          link.href = document.getElementById(chartId).toDataURL('image/png');
          document.body.appendChild(link);
          link.click();
          document.body.removeChild(link);
        });
        
        hideLoading();
      }, 500);
    }

    function exportDataAsCSV() {
      if (!currentData) return;
      
      showLoading("Preparando dados para exportação...");
      
      // Criar cabeçalhos
      const headers = ['Analista', 'Cluster', 'Data', 'Horário', 'Outage', 'Tecnologia'];
      
      // Criar linhas de dados
      const rows = currentData.map(item => {
        return [
          `"${loginToName[item.login]}"`,
          `"${item.cluster}"`,
          `"${item.date}"`,
          `"${item.time}"`,
          `"${item.outage}"`,
          `"${item.tecnologia}"`
        ].join(',');
      });
      
      // Combinar tudo
      const csvContent = [headers.join(','), ...rows].join('\n');
      
      // Criar link de download
      const link = document.createElement('a');
      link.download = 'dados_volumetria.csv';
      link.href = 'data:text/csv;charset=utf-8,' + encodeURIComponent(csvContent);
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      
      hideLoading();
    }

    // Event Listeners
    document.getElementById('uploadBtn').addEventListener('click', () => {
      document.getElementById('fileInput').click();
    });

    document.getElementById('fileInput').addEventListener('change', (e) => {
      if (e.target.files.length > 0) {
        processFiles([...e.target.files]);
      }
    });

    document.getElementById('exportPNG').addEventListener('click', exportChartsAsPNG);
    document.getElementById('exportCSV').addEventListener('click', exportDataAsCSV);

    // Drag and Drop
    const uploadArea = document.querySelector('.upload-area');
    
    uploadArea.addEventListener('dragover', (e) => {
      e.preventDefault();
      uploadArea.style.borderColor = 'var(--primary)';
      uploadArea.style.backgroundColor = 'rgba(67, 97, 238, 0.1)';
    });

    uploadArea.addEventListener('dragleave', () => {
      uploadArea.style.borderColor = 'var(--accent)';
      uploadArea.style.backgroundColor = 'var(--white)';
    });

    uploadArea.addEventListener('drop', (e) => {
      e.preventDefault();
      uploadArea.style.borderColor = 'var(--accent)';
      uploadArea.style.backgroundColor = 'var(--white)';
      
      if (e.dataTransfer.files.length > 0) {
        processFiles([...e.dataTransfer.files]);
      }
    });
  </script>
</body>
</html>
